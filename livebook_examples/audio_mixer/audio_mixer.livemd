# Mixing audio files

```elixir
File.cd(__DIR__)
Logger.configure(level: :error)

Mix.install([
  {:membrane_core, "~> 0.11.2"},
  {:membrane_audio_mix_plugin, "~> 0.12.0"},
  {:membrane_file_plugin, "~> 0.13.0"},
  {:membrane_mp3_mad_plugin, "~> 0.14.0"},
  {:membrane_ffmpeg_swresample_plugin, "~> 0.16.1"},
  {:membrane_aac_fdk_plugin, "~> 0.14.0"},
  {:membrane_kino_plugin, github: "membraneframework-labs/membrane_kino_plugin"}
])
```

## Installation

To run this demo one needs to install native dependencies:

1. [MP3 MAD](https://github.com/membraneframework/membrane_mp3_mad_plugin/tree/v0.14.0#installation)
2. [AAC FDK](https://github.com/membraneframework/membrane_aac_fdk_plugin#installation)
3. [SWResample FFmpeg](https://github.com/membraneframework/membrane_ffmpeg_swresample_plugin#installation)

```elixir
kino = Membrane.Kino.Player.new(:audio)
:ok
```

```elixir
defmodule Trimmer do
  use Membrane.Filter
  alias Membrane.Buffer

  def_options(
    start: [
      spec: Membrane.Time.t()
    ],
    stop: [
      spec: Membrane.Time.t() | :infinity
    ]
  )

  def_input_pad(:input,
    accepted_format: _any,
    demand_mode: :auto
  )

  def_output_pad(:output,
    accepted_format: _any,
    demand_mode: :auto
  )

  @impl true
  def handle_init(_ctx, options) do
    if options.start > options.stop do
      raise "Start time must be smaller than stop time"
    end

    state = Map.put(options, :first_pts, nil)
    {[], state}
  end

  @impl true
  def handle_process(:input, %Buffer{pts: pts}, _ctx, %{first_pts: nil} = state)
      when not is_nil(pts) do
    IO.inspect(pts, label: :pts)
    {[], %{state | first_pts: pts}}
  end

  @impl true
  def handle_process(:input, buffer = %Buffer{pts: pts}, _ctx, state)
      when not is_nil(pts) do
    if ignore_buffer?(buffer, state) do
      {[], state}
    else
      {[buffer: {:output, buffer}], state}
    end
  end

  defp ignore_buffer?(%Buffer{pts: pts}, state) do
    t = pts - state.first_pts
    IO.inspect(t)

    case state.stop do
      :infinity -> t <= state.start
      stop when is_integer(stop) -> t <= state.start or state.stop
    end
  end
end
```

```elixir
defmodule Membrane.Custom.Filter do
  use Membrane.Filter

  def_input_pad(:input,
    accepted_format: _any,
    demand_mode: :auto
  )

  def_output_pad(:output,
    accepted_format: _any,
    demand_mode: :auto
  )

  def_options(
    handle_end_of_stream: [
      spec:
        (pad :: Membrane.Pad.ref_t(),
         context :: Membrane.Element.CallbackContext.StreamManagement.t(),
         state :: Membrane.Element.state_t() ->
           Membrane.Element.Base.callback_return_t()),
      default: &__MODULE__.handle_end_of_stream_def/3
    ]
  )

  def handle_end_of_stream_def(_pad, _ctx, state) do
    {[{:end_of_stream, :output}], state}
  end

  @impl true
  def handle_end_of_stream(pad, ctx, state) do
    %{handle_end_of_stream: handle_end_of_stream} = state
    handle_end_of_stream.(pad, ctx, state)
  end

  @impl true
  def handle_process(:input, buffer, _ctx, state) do
    {[buffer: {:output, buffer}], state}
  end

  @impl true
  def handle_init(_ctx, options) do
    {[], options}
  end
end
```

```elixir
import Membrane.ChildrenSpec
alias Membrane.RemoteControlled, as: RC

alias Membrane.{
  File,
  AudioMixer,
  FFmpeg,
  RawAudio,
  AAC,
  Kino,
  Time,
  MP3
}

alias Membrane.Custom.Filter, as: MyFilter

n_beeps = 30
beep_filepath = "./assets/beep.aac"
background_filepath = "./assets/sample_music_short.mp3"

eos_filter = %MyFilter{
  handle_end_of_stream: fn pad, ctx, state ->
    IO.inspect(pad, label: :end_of_stream)
    MyFilter.handle_end_of_stream_def(pad, ctx, state)
  end
}

beeps_audio_inputs =
  for i <- 1..n_beeps do
    child({:file_source, i}, %File.Source{location: beep_filepath})
    |> child({:decoder_aac, i}, AAC.FDK.Decoder)
    |> via_in(:input, options: [offset: Time.seconds(i)])
    |> get_child(:mixer)
  end

background_audio_input =
  child(:file_source, %File.Source{location: background_filepath})
  |> child(:decoder_mp3, MP3.MAD.Decoder)
  |> child(:converter, %FFmpeg.SWResample.Converter{
    input_stream_format: %RawAudio{channels: 2, sample_format: :s24le, sample_rate: 44_100},
    output_stream_format: %RawAudio{channels: 1, sample_format: :s16le, sample_rate: 44_100}
  })
  |> get_child(:mixer)

mixer_output =
  child(:mixer, Membrane.AudioMixer)
  |> child({:eos_filter, 1}, eos_filter)
  |> child(:encoder_aac, AAC.FDK.Encoder)
  |> via_in(:audio)
  |> child(:player, %Kino.Player.Sink{kino: kino})

structure = beeps_audio_inputs ++ [background_audio_input, mixer_output]
:ok
```

```elixir
kino
```

```elixir
pipeline = RC.Pipeline.start!()
RC.Pipeline.exec_actions(pipeline, spec: structure, playback: :playing)
```

```elixir
Membrane.Pipeline.terminate(pipeline)
```
